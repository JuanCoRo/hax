---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: literals
    manifest: literals/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"literals.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false


namespace literals

def math_integers (x : hax_lib.int.Int) : RustM u8 := do
  let _ : hax_lib.int.Int ‚Üê (rust_primitives.hax.int.from_machine (3 : usize));
  let _neg_dec : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "-340282366920938463463374607431768211455000");
  let _pos_dec : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "340282366920938463463374607431768211455000");
  let _neg_hex : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "-340282366920938463463374607431768211455000");
  let _pos_hex : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "340282366920938463463374607431768211455000");
  let _neg_octal : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "-340282366920938463463374607431768211455000");
  let _pos_octal : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "340282366920938463463374607431768211455000");
  let _neg_bin : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "-340282366920938463463374607431768211455000");
  let _pos_bin : hax_lib.int.Int ‚Üê
    (hax_lib.int.Impl_7._unsafe_from_str
      "340282366920938463463374607431768211455000");
  let _ ‚Üê
    (rust_primitives.hax.int.gt
      (‚Üê (hax_lib.int.Impl_7._unsafe_from_str
        "-340282366920938463463374607431768211455000"))
      (‚Üê (hax_lib.int.Impl_7._unsafe_from_str
        "340282366920938463463374607431768211455000")));
  let _ ‚Üê (rust_primitives.hax.int.lt x x);
  let _ ‚Üê (rust_primitives.hax.int.ge x x);
  let _ ‚Üê (rust_primitives.hax.int.le x x);
  let _ ‚Üê (rust_primitives.hax.int.ne x x);
  let _ ‚Üê (rust_primitives.hax.int.eq x x);
  let _ ‚Üê (rust_primitives.hax.int.add x x);
  let _ ‚Üê (rust_primitives.hax.int.sub x x);
  let _ ‚Üê (rust_primitives.hax.int.mul x x);
  let _ ‚Üê (rust_primitives.hax.int.div x x);
  let _ : i16 ‚Üê (hax_lib.int.Impl_55.to_i16 x);
  let _ : i32 ‚Üê (hax_lib.int.Impl_57.to_i32 x);
  let _ : i64 ‚Üê (hax_lib.int.Impl_59.to_i64 x);
  let _ : i128 ‚Üê (hax_lib.int.Impl_61.to_i128 x);
  let _ : isize ‚Üê (hax_lib.int.Impl_63.to_isize x);
  let _ : u16 ‚Üê (hax_lib.int.Impl_43.to_u16 x);
  let _ : u32 ‚Üê (hax_lib.int.Impl_45.to_u32 x);
  let _ : u64 ‚Üê (hax_lib.int.Impl_47.to_u64 x);
  let _ : u128 ‚Üê (hax_lib.int.Impl_49.to_u128 x);
  let _ : usize ‚Üê (hax_lib.int.Impl_51.to_usize x);
  (hax_lib.int.Impl_41.to_u8
    (‚Üê (rust_primitives.hax.int.add x (‚Üê (rust_primitives.hax.int.mul x x)))))

set_option hax_mvcgen.specset "bv" in
@[hax_spec]
def math_integers.spec (x : hax_lib.int.Int) :
    Spec
      (requires := do
        ((‚Üê (rust_primitives.hax.int.gt
            x
            (‚Üê (hax_lib.int.Impl_7._unsafe_from_str "0"))))
          &&? (‚Üê (rust_primitives.hax.int.lt
            x
            (‚Üê (hax_lib.int.Impl_7._unsafe_from_str "16"))))))
      (ensures := fun _ => pure True)
      (math_integers (x : hax_lib.int.Int)) := {
  pureRequires := by hax_construct_pure <;> bv_decide
  pureEnsures := by hax_construct_pure <;> bv_decide
  contract := by hax_mvcgen [math_integers] <;> bv_decide
}

@[spec]
def panic_with_msg (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  (rust_primitives.hax.never_to_any
    (‚Üê (core_models.panicking.panic_fmt
      (‚Üê (core_models.fmt.rt.Impl_1.new_const ((1 : usize))
        (RustArray.ofVec #v["with msg"]))))))

structure Foo where
  field : u8

@[instance] opaque Impl.AssociatedTypes :
  core_models.marker.StructuralPartialEq.AssociatedTypes Foo :=
  by constructor <;> exact Inhabited.default

@[instance] opaque Impl :
  core_models.marker.StructuralPartialEq Foo :=
  by constructor <;> exact Inhabited.default

@[instance] opaque Impl_1.AssociatedTypes :
  core_models.cmp.PartialEq.AssociatedTypes Foo Foo :=
  by constructor <;> exact Inhabited.default

@[instance] opaque Impl_1 :
  core_models.cmp.PartialEq Foo Foo :=
  by constructor <;> exact Inhabited.default

@[instance] opaque Impl_2.AssociatedTypes :
  core_models.cmp.Eq.AssociatedTypes Foo :=
  by constructor <;> exact Inhabited.default

@[instance] opaque Impl_2 :
  core_models.cmp.Eq Foo :=
  by constructor <;> exact Inhabited.default

def CONSTANT : Foo := RustM.of_isOk (do (Foo.mk (field := (3 : u8)))) (by rfl)

@[spec]
def numeric (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ : usize := (123 : usize);
  let _ : isize := (-42 : isize);
  let _ : isize := (42 : isize);
  let _ : i32 := (-42 : i32);
  let _ : u128 := (22222222222222222222 : u128);
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def patterns (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ ‚Üê
    match (1 : u8) with
      | 2 => do (pure rust_primitives.hax.Tuple0.mk)
      | _ => do (pure rust_primitives.hax.Tuple0.mk);
  let _ ‚Üê
    match
      (rust_primitives.hax.Tuple2.mk
        "hello"
        (rust_primitives.hax.Tuple2.mk
          (123 : i32)
          (RustArray.ofVec #v["a", "b"])))
    with
      | ‚ü®"hello", ‚ü®123, _todo‚ü©‚ü© => do (pure rust_primitives.hax.Tuple0.mk)
      | _ => do (pure rust_primitives.hax.Tuple0.mk);
  let _ ‚Üê
    match (Foo.mk (field := (4 : u8))) with
      | {field := 3} => do (pure rust_primitives.hax.Tuple0.mk)
      | _ => do (pure rust_primitives.hax.Tuple0.mk);
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def casts (x8 : u8) (x16 : u16) (x32 : u32) (x64 : u64) (xs : usize) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ : u64 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê ((‚Üê (rust_primitives.hax.cast_op x8 : RustM u64))
            +? (‚Üê (rust_primitives.hax.cast_op x16 : RustM u64))))
          +? (‚Üê (rust_primitives.hax.cast_op x32 : RustM u64))))
        +? x64))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM u64)));
  let _ : u32 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê ((‚Üê (rust_primitives.hax.cast_op x8 : RustM u32))
            +? (‚Üê (rust_primitives.hax.cast_op x16 : RustM u32))))
          +? x32))
        +? (‚Üê (rust_primitives.hax.cast_op x64 : RustM u32))))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM u32)));
  let _ : u16 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê ((‚Üê (rust_primitives.hax.cast_op x8 : RustM u16)) +? x16))
          +? (‚Üê (rust_primitives.hax.cast_op x32 : RustM u16))))
        +? (‚Üê (rust_primitives.hax.cast_op x64 : RustM u16))))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM u16)));
  let _ : u8 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê (x8 +? (‚Üê (rust_primitives.hax.cast_op x16 : RustM u8))))
          +? (‚Üê (rust_primitives.hax.cast_op x32 : RustM u8))))
        +? (‚Üê (rust_primitives.hax.cast_op x64 : RustM u8))))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM u8)));
  let _ : i64 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê ((‚Üê (rust_primitives.hax.cast_op x8 : RustM i64))
            +? (‚Üê (rust_primitives.hax.cast_op x16 : RustM i64))))
          +? (‚Üê (rust_primitives.hax.cast_op x32 : RustM i64))))
        +? (‚Üê (rust_primitives.hax.cast_op x64 : RustM i64))))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM i64)));
  let _ : i32 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê ((‚Üê (rust_primitives.hax.cast_op x8 : RustM i32))
            +? (‚Üê (rust_primitives.hax.cast_op x16 : RustM i32))))
          +? (‚Üê (rust_primitives.hax.cast_op x32 : RustM i32))))
        +? (‚Üê (rust_primitives.hax.cast_op x64 : RustM i32))))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM i32)));
  let _ : i16 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê ((‚Üê (rust_primitives.hax.cast_op x8 : RustM i16))
            +? (‚Üê (rust_primitives.hax.cast_op x16 : RustM i16))))
          +? (‚Üê (rust_primitives.hax.cast_op x32 : RustM i16))))
        +? (‚Üê (rust_primitives.hax.cast_op x64 : RustM i16))))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM i16)));
  let _ : i8 ‚Üê
    ((‚Üê ((‚Üê ((‚Üê ((‚Üê (rust_primitives.hax.cast_op x8 : RustM i8))
            +? (‚Üê (rust_primitives.hax.cast_op x16 : RustM i8))))
          +? (‚Üê (rust_primitives.hax.cast_op x32 : RustM i8))))
        +? (‚Üê (rust_primitives.hax.cast_op x64 : RustM i8))))
      +? (‚Üê (rust_primitives.hax.cast_op xs : RustM i8)));
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def empty_array (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ : (RustSlice u8) ‚Üê (rust_primitives.unsize (RustArray.ofVec #v[]));
  (pure rust_primitives.hax.Tuple0.mk)

--  https://github.com/hacspec/hax/issues/500
@[spec]
def fn_pointer_cast (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let f : (u32 -> RustM u32) := (fun x => (do (pure x) : RustM u32));
  (pure rust_primitives.hax.Tuple0.mk)

@[spec]
def strings (_ : rust_primitives.hax.Tuple0) :
    RustM rust_primitives.hax.Tuple0 := do
  let _ : String := "hello";
  let _ : String := "hello\"world";
  let _ : String := "it\'s";
  let _ : String := "back\\slash";
  let _ : String := "line\nbreak";
  let _ : String := "carriage\rreturn";
  let _ : String := "tab\there";
  let _ : String := "null\x00byte";
  let _ : String := "bell\x07char";
  let _ : String := "\x1b[0m";
  let _ : String := "ü¶Ä";
  (pure rust_primitives.hax.Tuple0.mk)

end literals

'''
